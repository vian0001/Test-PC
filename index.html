
<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° ULTRA BENCHMARK PRO v2 - Jovian.my.id</title>
    <style>
        :root {
            --bg: #030306;
            --card: #0a0a12;
            --border: rgba(255,255,255,0.08);
            --cpu: #ff2d55;
            --ram: #30d158;
            --gpu: #bf5af2;
            --total: #00d4ff;
            --danger: #ff453a;
            --warning: #ff9f0a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Warning Banner */
        .warning-banner {
            background: linear-gradient(135deg, #ff6b35, #ff2d55);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            animation: warningPulse 2s ease infinite;
        }

        @keyframes warningPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 45, 85, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 45, 85, 0.7); }
        }

        .warning-icon { font-size: 2rem; margin-bottom: 10px; }
        .warning-title { font-size: 1.2rem; font-weight: 800; margin-bottom: 8px; }
        .warning-text { font-size: 0.85rem; opacity: 0.9; line-height: 1.5; }

        .header {
            text-align: center;
            padding: 30px 20px 40px;
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            height: 400px;
            background: radial-gradient(ellipse, rgba(191, 90, 242, 0.25) 0%, transparent 60%);
            pointer-events: none;
        }

        .logo {
            font-size: 2.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--cpu), var(--warning), var(--gpu), var(--total));
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tagline {
            color: #888;
            margin-top: 10px;
            font-size: 0.95rem;
            letter-spacing: 2px;
        }

        .brand-link {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 20px;
            background: linear-gradient(135deg, var(--gpu), var(--total));
            border-radius: 30px;
            color: white;
            text-decoration: none;
            font-weight: 700;
            font-size: 0.9rem;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .brand-link:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(191, 90, 242, 0.5);
        }

        /* Timer Selection */
        .timer-section {
            background: var(--card);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .timer-title {
            text-align: center;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--total);
        }

        .timer-grid {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .timer-btn {
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 700;
            border: 2px solid var(--total);
            background: transparent;
            color: var(--total);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .timer-btn:hover, .timer-btn.active {
            background: var(--total);
            color: #000;
            transform: scale(1.05);
        }

        .timer-btn.active {
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .timer-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Countdown Display */
        .countdown-display {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            background: var(--bg);
            border-radius: 16px;
        }

        .countdown-label { font-size: 0.8rem; color: #666; text-transform: uppercase; }
        .countdown-value { font-size: 4rem; font-weight: 900; color: var(--total); font-variant-numeric: tabular-nums; }
        .countdown-progress {
            width: 100%;
            height: 8px;
            background: #1a1a24;
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
        }
        .countdown-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--total), var(--gpu));
            border-radius: 4px;
            transition: width 0.1s;
        }

        /* Controls */
        .controls {
            background: var(--card);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .control-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }

        .btn {
            padding: 14px 28px;
            font-size: 0.95rem;
            font-weight: 700;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .btn-start {
            background: linear-gradient(135deg, #00c853, #00e676);
            color: #000;
            font-size: 1.2rem;
            padding: 18px 50px;
            box-shadow: 0 0 30px rgba(0, 200, 83, 0.4);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff1744, #ff5252);
            color: white;
            font-size: 1.2rem;
            padding: 18px 50px;
        }

        .btn-cpu { background: linear-gradient(135deg, var(--cpu), #ff6b8a); color: white; }
        .btn-ram { background: linear-gradient(135deg, var(--ram), #5de888); color: #000; }
        .btn-gpu { background: linear-gradient(135deg, var(--gpu), #d88aff); color: white; }

        /* Worker Status */
        .worker-status {
            background: var(--bg);
            border-radius: 14px;
            padding: 18px;
            margin-top: 20px;
        }

        .worker-title {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 12px;
            text-align: center;
        }

        .worker-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .worker-dot {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #1a1a24;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 700;
            transition: all 0.3s;
        }

        .worker-dot.active {
            background: var(--cpu);
            border-color: var(--cpu);
            box-shadow: 0 0 15px var(--cpu);
            animation: pulse 0.5s ease infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.15); }
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--card);
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--stat-color);
        }

        .stat-card.cpu { --stat-color: var(--cpu); }
        .stat-card.ram { --stat-color: var(--ram); }
        .stat-card.gpu { --stat-color: var(--gpu); }
        .stat-card.fps { --stat-color: var(--warning); }

        .stat-label {
            font-size: 0.7rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            color: var(--stat-color);
            font-variant-numeric: tabular-nums;
        }

        .stat-sub {
            font-size: 0.75rem;
            color: #444;
            margin-top: 4px;
        }

        /* Usage Grid */
        .usage-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .usage-grid { grid-template-columns: 1fr; }
        }

        .usage-card {
            background: var(--card);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid var(--border);
            text-align: center;
        }

        .usage-card.stress { animation: stressGlow 0.5s ease infinite alternate; }
        .usage-card.cpu-card.stress { --glow-color: var(--cpu); }
        .usage-card.ram-card.stress { --glow-color: var(--ram); }
        .usage-card.gpu-card.stress { --glow-color: var(--gpu); }

        @keyframes stressGlow {
            from { box-shadow: 0 0 0 0 var(--glow-color, transparent); }
            to { box-shadow: 0 0 30px 3px var(--glow-color, transparent); }
        }

        .usage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .usage-icon {
            width: 50px;
            height: 50px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
        }

        .usage-icon.cpu { background: linear-gradient(135deg, var(--cpu), #ff6b8a); }
        .usage-icon.ram { background: linear-gradient(135deg, var(--ram), #5de888); }
        .usage-icon.gpu { background: linear-gradient(135deg, var(--gpu), #d88aff); }

        .usage-percent { font-size: 2.5rem; font-weight: 900; }
        .usage-percent.cpu { color: var(--cpu); }
        .usage-percent.ram { color: var(--ram); }
        .usage-percent.gpu { color: var(--gpu); }

        /* Progress Ring */
        .progress-ring {
            width: 160px;
            height: 160px;
            margin: 15px auto;
            position: relative;
        }

        .progress-ring svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 10;
            stroke-linecap: round;
        }

        .progress-ring .bg { stroke: #1a1a24; }
        .progress-ring .progress {
            stroke-dasharray: 440;
            stroke-dashoffset: 440;
            transition: stroke-dashoffset 0.15s;
        }

        .progress-ring.cpu .progress { stroke: var(--cpu); filter: drop-shadow(0 0 8px var(--cpu)); }
        .progress-ring.ram .progress { stroke: var(--ram); filter: drop-shadow(0 0 8px var(--ram)); }
        .progress-ring.gpu .progress { stroke: var(--gpu); filter: drop-shadow(0 0 8px var(--gpu)); }

        .progress-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.2rem;
            font-weight: 900;
        }

        /* Metrics */
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        .metric {
            background: var(--bg);
            padding: 10px;
            border-radius: 10px;
            text-align: left;
        }

        .metric-label { font-size: 0.65rem; color: #444; text-transform: uppercase; }
        .metric-value { font-size: 0.9rem; font-weight: 700; font-variant-numeric: tabular-nums; }

        /* Canvas */
        .canvas-section {
            background: var(--card);
            border-radius: 20px;
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .canvas-title { font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .canvas-stats { display: flex; gap: 15px; font-size: 0.8rem; flex-wrap: wrap; }
        .canvas-stat span:first-child { color: #555; }
        .canvas-stat span:last-child { color: var(--gpu); font-weight: 700; }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 350px;
            background: #000;
            border-radius: 14px;
            overflow: hidden;
        }

        #gpuCanvas { width: 100%; height: 100%; display: block; }

        /* WebGL Info */
        .webgl-info {
            background: var(--bg);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.75rem;
            color: #666;
        }

        .webgl-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .webgl-item span:first-child { color: #444; }
        .webgl-item span:last-child { color: var(--gpu); font-weight: 600; }

        /* Score Categories */
        .score-categories {
            background: var(--card);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .categories-title {
            text-align: center;
            font-weight: 700;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .category-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 12px;
            background: var(--bg);
        }

        .category-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 800;
            font-size: 0.75rem;
            min-width: 110px;
            text-align: center;
        }

        .category-badge.legendary { background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000; }
        .category-badge.extreme { background: linear-gradient(135deg, #ff0844, #ff4444); color: #fff; }
        .category-badge.excellent { background: var(--ram); color: #000; }
        .category-badge.good { background: var(--total); color: #000; }
        .category-badge.average { background: var(--warning); color: #000; }
        .category-badge.poor { background: #666; color: #fff; }

        .category-range { font-size: 0.85rem; color: #888; }

        /* Results Section */
        .results-section {
            background: var(--card);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
            display: none;
        }

        .results-section.show { display: block; }

        .results-title {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 900;
            margin-bottom: 25px;
            color: var(--total);
        }

        .final-score {
            text-align: center;
            margin-bottom: 30px;
        }

        .final-score-label { font-size: 0.9rem; color: #666; text-transform: uppercase; letter-spacing: 3px; }
        .final-score-value {
            font-size: 5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--cpu), var(--total), var(--gpu));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            line-height: 1.1;
        }

        .score-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        @media (max-width: 700px) {
            .score-stats-grid { grid-template-columns: 1fr; }
        }

        .score-stat-card {
            background: var(--bg);
            border-radius: 14px;
            padding: 20px;
            text-align: center;
        }

        .score-stat-title { font-size: 0.8rem; color: #555; text-transform: uppercase; margin-bottom: 10px; }
        .score-stat-values { display: flex; justify-content: space-around; gap: 10px; }
        .score-stat-item .label { font-size: 0.65rem; color: #444; }
        .score-stat-item .value { font-size: 1.2rem; font-weight: 800; }
        .score-stat-item .value.min { color: var(--danger); }
        .score-stat-item .value.avg { color: var(--warning); }
        .score-stat-item .value.max { color: var(--ram); }

        /* Live Score */
        .live-score {
            background: var(--card);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 1px solid var(--border);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .live-score::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--cpu), var(--ram), var(--gpu), var(--total));
        }

        .live-score-label { font-size: 0.85rem; color: #555; text-transform: uppercase; letter-spacing: 3px; }
        .live-score-value {
            font-size: 4.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--cpu), var(--total), var(--gpu));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            line-height: 1.2;
        }

        .live-breakdown {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .breakdown-item { text-align: center; }
        .breakdown-label { font-size: 0.7rem; color: #444; text-transform: uppercase; }
        .breakdown-value { font-size: 1.6rem; font-weight: 800; }
        .breakdown-value.cpu { color: var(--cpu); }
        .breakdown-value.ram { color: var(--ram); }
        .breakdown-value.gpu { color: var(--gpu); }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .charts-grid { grid-template-columns: 1fr; }
        }

        .chart-card {
            background: var(--card);
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
        }

        .chart-title {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chart-title.cpu { color: var(--cpu); }
        .chart-title.ram { color: var(--ram); }
        .chart-title.gpu { color: var(--gpu); }

        .chart-container { height: 100px; }
        .chart-container canvas { width: 100%; height: 100%; }

        /* Log */
        .log-section {
            background: var(--card);
            border-radius: 14px;
            padding: 18px;
            border: 1px solid var(--border);
            margin-bottom: 20px;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .log-title { font-weight: 700; font-size: 0.9rem; }

        .log-container {
            background: var(--bg);
            border-radius: 10px;
            padding: 12px;
            max-height: 180px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.03);
            display: flex;
            gap: 8px;
        }

        .log-time { color: #333; min-width: 65px; }
        .log-type { min-width: 45px; font-weight: 600; }
        .log-type.info { color: var(--total); }
        .log-type.cpu { color: var(--cpu); }
        .log-type.ram { color: var(--ram); }
        .log-type.gpu { color: var(--gpu); }
        .log-type.warn { color: var(--warning); }
        .log-type.done { color: var(--ram); }
        .log-msg { color: #666; }

        /* Footer */
        .footer {
            background: var(--card);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .footer-brand {
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--gpu), var(--total));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
        }

        .footer-copyright {
            font-size: 0.8rem;
            color: #555;
            margin-bottom: 15px;
        }

        .footer-link {
            display: inline-block;
            padding: 10px 30px;
            background: linear-gradient(135deg, var(--gpu), var(--total));
            border-radius: 30px;
            color: white;
            text-decoration: none;
            font-weight: 700;
            transition: all 0.3s;
        }

        .footer-link:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(191, 90, 242, 0.5);
        }

        .footer-disclaimer {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: #444;
            line-height: 1.6;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--total); border-radius: 3px; }

        @media (max-width: 600px) {
            .logo { font-size: 1.6rem; }
            .btn { padding: 10px 18px; font-size: 0.8rem; }
            .btn-start, .btn-stop { padding: 14px 30px; font-size: 1rem; }
            .live-score-value { font-size: 3rem; }
            .final-score-value { font-size: 3.5rem; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .countdown-value { font-size: 3rem; }
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Warning Banner -->
        <div class="warning-banner">
            <div class="warning-icon">‚ö†Ô∏è</div>
            <div class="warning-title">PERINGATAN PENTING!</div>
            <div class="warning-text">
                Benchmark ini akan memberikan beban berat pada CPU, RAM, dan GPU perangkat Anda.<br>
                Pastikan perangkat memiliki pendinginan yang memadai. Gunakan dengan risiko Anda sendiri.<br>
                Hentikan segera jika perangkat terasa terlalu panas atau tidak responsif.
            </div>
        </div>

        <header class="header">
            <h1 class="logo">‚ö° ULTRA BENCHMARK PRO v2</h1>
            <p class="tagline">MAXIMUM STRESS TEST ‚Ä¢ WEBGL ACCELERATED</p>
            <a href="https://Jovian.my.id" target="_blank" class="brand-link">üåê Jovian.my.id</a>
        </header>

        <!-- Timer Selection -->
        <div class="timer-section">
            <div class="timer-title">‚è±Ô∏è SELECT BENCHMARK DURATION</div>
            <div class="timer-grid">
                <button class="timer-btn" data-time="30">30 SEC</button>
                <button class="timer-btn" data-time="60">1 MIN</button>
                <button class="timer-btn" data-time="120">2 MIN</button>
                <button class="timer-btn active" data-time="300">5 MIN</button>
                <button class="timer-btn" data-time="600">10 MIN</button>
            </div>
            <div class="countdown-display">
                <div class="countdown-label">Time Remaining</div>
                <div class="countdown-value" id="countdown">05:00</div>
                <div class="countdown-progress">
                    <div class="countdown-bar" id="countdownBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-grid">
                <button class="btn btn-start" id="btnStart">‚ñ∂Ô∏è START BENCHMARK</button>
                <button class="btn btn-stop" id="btnStop" disabled>‚èπÔ∏è STOP</button>
            </div>
            <div class="control-grid" style="margin-top: 15px;">
                <button class="btn btn-cpu" id="btnCpu">üî¥ CPU Only</button>
                <button class="btn btn-ram" id="btnRam">üü¢ RAM Only</button>
                <button class="btn btn-gpu" id="btnGpu">üü£ GPU Only</button>
            </div>
            <div class="worker-status">
                <div class="worker-title">CPU WORKER THREADS (<span id="coreCount">0</span> Cores Detected)</div>
                <div class="worker-grid" id="workerGrid"></div>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-grid">
            <div class="stat-card cpu">
                <div class="stat-label">CPU Load</div>
                <div class="stat-value" id="cpuUsageSmall">0%</div>
                <div class="stat-sub">Workers: <span id="activeWorkers">0</span></div>
            </div>
            <div class="stat-card ram">
                <div class="stat-label">RAM Used</div>
                <div class="stat-value" id="ramUsageSmall">0 MB</div>
                <div class="stat-sub">Buffers: <span id="bufferCount">0</span></div>
            </div>
            <div class="stat-card gpu">
                <div class="stat-label">GPU Load</div>
                <div class="stat-value" id="gpuUsageSmall">0%</div>
                <div class="stat-sub">Objects: <span id="objectCount">0</span></div>
            </div>
            <div class="stat-card fps">
                <div class="stat-label">Render FPS</div>
                <div class="stat-value" id="fpsDisplay">0</div>
                <div class="stat-sub">Max: <span id="fpsMax">0</span></div>
            </div>
        </div>

        <!-- Usage Cards -->
        <div class="usage-grid">
            <div class="usage-card cpu-card" id="cpuCard">
                <div class="usage-header">
                    <div class="usage-icon cpu">üî•</div>
                    <div class="usage-percent cpu" id="cpuPercent">0%</div>
                </div>
                <div class="progress-ring cpu">
                    <svg viewBox="0 0 160 160">
                        <circle class="bg" cx="80" cy="80" r="70"/>
                        <circle class="progress" cx="80" cy="80" r="70" id="cpuRing"/>
                    </svg>
                    <div class="progress-value" id="cpuRingValue" style="color: var(--cpu);">0</div>
                </div>
                <div style="font-weight: 700; margin-bottom: 4px;">CPU STRESS</div>
                <div style="font-size: 0.75rem; color: #555;" id="cpuStatus">Ready</div>
                <div class="metrics">
                    <div class="metric"><div class="metric-label">Operations</div><div class="metric-value" id="cpuOps">0</div></div>
                    <div class="metric"><div class="metric-label">Ops/Sec</div><div class="metric-value" id="cpuOpsPerSec">0</div></div>
                    <div class="metric"><div class="metric-label">Threads</div><div class="metric-value" id="cpuThreads">0</div></div>
                    <div class="metric"><div class="metric-label">Score</div><div class="metric-value" id="cpuScore">0</div></div>
                </div>
            </div>

            <div class="usage-card ram-card" id="ramCard">
                <div class="usage-header">
                    <div class="usage-icon ram">üíæ</div>
                    <div class="usage-percent ram" id="ramPercent">0%</div>
                </div>
                <div class="progress-ring ram">
                    <svg viewBox="0 0 160 160">
                        <circle class="bg" cx="80" cy="80" r="70"/>
                        <circle class="progress" cx="80" cy="80" r="70" id="ramRing"/>
                    </svg>
                    <div class="progress-value" id="ramRingValue" style="color: var(--ram);">0</div>
                </div>
                <div style="font-weight: 700; margin-bottom: 4px;">RAM STRESS</div>
                <div style="font-size: 0.75rem; color: #555;" id="ramStatus">Ready</div>
                <div class="metrics">
                    <div class="metric"><div class="metric-label">Allocated</div><div class="metric-value" id="ramAllocated">0 MB</div></div>
                    <div class="metric"><div class="metric-label">Write MB/s</div><div class="metric-value" id="ramWrite">0</div></div>
                    <div class="metric"><div class="metric-label">Buffers</div><div class="metric-value" id="ramBuffers">0</div></div>
                    <div class="metric"><div class="metric-label">Score</div><div class="metric-value" id="ramScore">0</div></div>
                </div>
            </div>

            <div class="usage-card gpu-card" id="gpuCard">
                <div class="usage-header">
                    <div class="usage-icon gpu">üéÆ</div>
                    <div class="usage-percent gpu" id="gpuPercent">0%</div>
                </div>
                <div class="progress-ring gpu">
                    <svg viewBox="0 0 160 160">
                        <circle class="bg" cx="80" cy="80" r="70"/>
                        <circle class="progress" cx="80" cy="80" r="70" id="gpuRing"/>
                    </svg>
                    <div class="progress-value" id="gpuRingValue" style="color: var(--gpu);">0</div>
                </div>
                <div style="font-weight: 700; margin-bottom: 4px;">GPU STRESS</div>
                <div style="font-size: 0.75rem; color: #555;" id="gpuStatus">Ready</div>
                <div class="metrics">
                    <div class="metric"><div class="metric-label">Vertices</div><div class="metric-value" id="gpuVertices">0</div></div>
                    <div class="metric"><div class="metric-label">Draw Calls</div><div class="metric-value" id="gpuDrawCalls">0</div></div>
                    <div class="metric"><div class="metric-label">Triangles</div><div class="metric-value" id="gpuTriangles">0</div></div>
                    <div class="metric"><div class="metric-label">Score</div><div class="metric-value" id="gpuScore">0</div></div>
                </div>
            </div>
        </div>

        <!-- GPU Canvas -->
        <div class="canvas-section">
            <div class="canvas-header">
                <div class="canvas-title">üé® WebGL GPU Render</div>
                <div class="canvas-stats">
                    <div class="canvas-stat"><span>Triangles:</span> <span id="canvasTriangles">0</span></div>
                    <div class="canvas-stat"><span>Vertices:</span> <span id="canvasVertices">0</span></div>
                    <div class="canvas-stat"><span>FPS:</span> <span id="canvasFps">0</span></div>
                </div>
            </div>
            <div class="canvas-container">
                <canvas id="gpuCanvas"></canvas>
            </div>
            <div class="webgl-info">
                <div class="webgl-info-grid">
                    <div class="webgl-item"><span>Renderer: </span><span id="glRenderer">-</span></div>
                    <div class="webgl-item"><span>Vendor: </span><span id="glVendor">-</span></div>
                    <div class="webgl-item"><span>Max Texture: </span><span id="glMaxTexture">-</span></div>
                    <div class="webgl-item"><span>Max Vertices: </span><span id="glMaxVertices">-</span></div>
                </div>
            </div>
        </div>

        <!-- Score Categories Reference (1.5x) -->
        <div class="score-categories">
            <div class="categories-title">üìä SCORE CATEGORIES (1.5x Scale)</div>
            <div class="categories-grid">
                <div class="category-item">
                    <span class="category-badge legendary">üèÜ LEGENDARY</span>
                    <span class="category-range">‚â• 7,500,000</span>
                </div>
                <div class="category-item">
                    <span class="category-badge extreme">üî• EXTREME</span>
                    <span class="category-range">3,000,000 - 7,499,999</span>
                </div>
                <div class="category-item">
                    <span class="category-badge excellent">‚≠ê EXCELLENT</span>
                    <span class="category-range">1,500,000 - 2,999,999</span>
                </div>
                <div class="category-item">
                    <span class="category-badge good">‚úì GOOD</span>
                    <span class="category-range">750,000 - 1,499,999</span>
                </div>
                <div class="category-item">
                    <span class="category-badge average">‚óÜ AVERAGE</span>
                    <span class="category-range">300,000 - 749,999</span>
                </div>
                <div class="category-item">
                    <span class="category-badge poor">‚óã POOR</span>
                    <span class="category-range">< 300,000</span>
                </div>
            </div>
        </div>

        <!-- Live Score -->
        <div class="live-score">
            <div class="live-score-label">Current Total Score</div>
            <div class="live-score-value" id="totalScore">0</div>
            <div id="scoreRating"></div>
            <div class="live-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-label">CPU</div>
                    <div class="breakdown-value cpu" id="breakdownCpu">0</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">RAM</div>
                    <div class="breakdown-value ram" id="breakdownRam">0</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">GPU</div>
                    <div class="breakdown-value gpu" id="breakdownGpu">0</div>
                </div>
            </div>
        </div>

        <!-- Final Results -->
        <div class="results-section" id="resultsSection">
            <div class="results-title">üèÅ BENCHMARK COMPLETE!</div>
            <div class="final-score">
                <div class="final-score-label">Final Score</div>
                <div class="final-score-value" id="finalScore">0</div>
                <div id="finalRating"></div>
            </div>
            <div class="score-stats-grid">
                <div class="score-stat-card">
                    <div class="score-stat-title">üî¥ CPU Score</div>
                    <div class="score-stat-values">
                        <div class="score-stat-item"><div class="label">MIN</div><div class="value min" id="cpuMin">0</div></div>
                        <div class="score-stat-item"><div class="label">AVG</div><div class="value avg" id="cpuAvg">0</div></div>
                        <div class="score-stat-item"><div class="label">MAX</div><div class="value max" id="cpuMax">0</div></div>
                    </div>
                </div>
                <div class="score-stat-card">
                    <div class="score-stat-title">üü¢ RAM Score</div>
                    <div class="score-stat-values">
                        <div class="score-stat-item"><div class="label">MIN</div><div class="value min" id="ramMin">0</div></div>
                        <div class="score-stat-item"><div class="label">AVG</div><div class="value avg" id="ramAvg">0</div></div>
                        <div class="score-stat-item"><div class="label">MAX</div><div class="value max" id="ramMax">0</div></div>
                    </div>
                </div>
                <div class="score-stat-card">
                    <div class="score-stat-title">üü£ GPU Score</div>
                    <div class="score-stat-values">
                        <div class="score-stat-item"><div class="label">MIN</div><div class="value min" id="gpuMin">0</div></div>
                        <div class="score-stat-item"><div class="label">AVG</div><div class="value avg" id="gpuAvg">0</div></div>
                        <div class="score-stat-item"><div class="label">MAX</div><div class="value max" id="gpuMax">0</div></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="charts-grid">
            <div class="chart-card">
                <div class="chart-title cpu">üìà CPU History</div>
                <div class="chart-container"><canvas id="cpuChart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title ram">üìà RAM History</div>
                <div class="chart-container"><canvas id="ramChart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title gpu">üìà GPU History</div>
                <div class="chart-container"><canvas id="gpuChart"></canvas></div>
            </div>
        </div>

        <!-- Log -->
        <div class="log-section">
            <div class="log-header">
                <div class="log-title">üìã System Log</div>
                <button class="btn" id="btnClearLog" style="padding: 6px 14px; font-size: 0.7rem; background: #333;">Clear</button>
            </div>
            <div class="log-container" id="logContainer"></div>
        </div>

        <!-- Footer with Copyright -->
        <footer class="footer">
            <div class="footer-brand">Jovian.my.id</div>
            <div class="footer-copyright">¬© 2025 Jovian.my.id - All Rights Reserved</div>
            <a href="https://Jovian.my.id" target="_blank" class="footer-link">üåê Visit Website</a>
            <div class="footer-disclaimer">
                <strong>Disclaimer:</strong> Tool benchmark ini disediakan "sebagaimana adanya" tanpa jaminan apapun.<br>
                Penggunaan tool ini sepenuhnya menjadi tanggung jawab pengguna.<br>
                Jovian.my.id tidak bertanggung jawab atas kerusakan perangkat yang mungkin terjadi.<br>
                Pastikan perangkat Anda memiliki sistem pendinginan yang memadai sebelum menjalankan stress test.
            </div>
        </footer>
    </div>

    <script>
        'use strict';

        const CONFIG = {
            MAX_TRIANGLES: 500000,
            TRIANGLE_BATCH: 5000,
            MAX_RAM_MB: 2000,
            RAM_CHUNK_MB: 50,
            CHART_SIZE: 60,
            RING_CIRCUMFERENCE: 440,
            MAX_USAGE_PERCENT: 85,
            SCORE_MULTIPLIER: 1.5
        };

        const state = {
            running: { cpu: false, ram: false, gpu: false, any: false },
            workers: [],
            workerStats: [],
            scores: { cpu: 0, ram: 0, gpu: 0 },
            scoreHistory: { cpu: [], ram: [], gpu: [] },
            usage: { cpu: 0, ram: 0, gpu: 0 },
            charts: { cpu: [], ram: [], gpu: [] },
            ramBuffers: [],
            fps: { current: 0, max: 0, frames: 0, lastTime: 0 },
            timer: { duration: 300, remaining: 300, interval: null, startTime: 0 },
            gl: null,
            glProgram: null,
            triangleCount: 0,
            vertexCount: 0,
            drawCalls: 0
        };

        const $ = id => document.getElementById(id);
        const DOM = {
            btnStart: $('btnStart'), btnStop: $('btnStop'),
            btnCpu: $('btnCpu'), btnRam: $('btnRam'), btnGpu: $('btnGpu'),
            btnClearLog: $('btnClearLog'),
            workerGrid: $('workerGrid'), coreCount: $('coreCount'),
            countdown: $('countdown'), countdownBar: $('countdownBar'),
            logContainer: $('logContainer'), gpuCanvas: $('gpuCanvas'),
            resultsSection: $('resultsSection'),
            cpuUsageSmall: $('cpuUsageSmall'), ramUsageSmall: $('ramUsageSmall'),
            gpuUsageSmall: $('gpuUsageSmall'), fpsDisplay: $('fpsDisplay'),
            fpsMax: $('fpsMax'), activeWorkers: $('activeWorkers'),
            bufferCount: $('bufferCount'), objectCount: $('objectCount'),
            cpuCard: $('cpuCard'), cpuPercent: $('cpuPercent'),
            cpuRing: $('cpuRing'), cpuRingValue: $('cpuRingValue'),
            cpuStatus: $('cpuStatus'), cpuOps: $('cpuOps'),
            cpuOpsPerSec: $('cpuOpsPerSec'), cpuThreads: $('cpuThreads'), cpuScore: $('cpuScore'),
            ramCard: $('ramCard'), ramPercent: $('ramPercent'),
            ramRing: $('ramRing'), ramRingValue: $('ramRingValue'),
            ramStatus: $('ramStatus'), ramAllocated: $('ramAllocated'),
            ramWrite: $('ramWrite'), ramBuffers: $('ramBuffers'), ramScore: $('ramScore'),
            gpuCard: $('gpuCard'), gpuPercent: $('gpuPercent'),
            gpuRing: $('gpuRing'), gpuRingValue: $('gpuRingValue'),
            gpuStatus: $('gpuStatus'), gpuVertices: $('gpuVertices'),
            gpuDrawCalls: $('gpuDrawCalls'), gpuTriangles: $('gpuTriangles'), gpuScore: $('gpuScore'),
            canvasTriangles: $('canvasTriangles'), canvasVertices: $('canvasVertices'), canvasFps: $('canvasFps'),
            glRenderer: $('glRenderer'), glVendor: $('glVendor'),
            glMaxTexture: $('glMaxTexture'), glMaxVertices: $('glMaxVertices'),
            totalScore: $('totalScore'), scoreRating: $('scoreRating'),
            breakdownCpu: $('breakdownCpu'), breakdownRam: $('breakdownRam'), breakdownGpu: $('breakdownGpu'),
            finalScore: $('finalScore'), finalRating: $('finalRating'),
            cpuMin: $('cpuMin'), cpuAvg: $('cpuAvg'), cpuMax: $('cpuMax'),
            ramMin: $('ramMin'), ramAvg: $('ramAvg'), ramMax: $('ramMax'),
            gpuMin: $('gpuMin'), gpuAvg: $('gpuAvg'), gpuMax: $('gpuMax'),
            cpuChart: $('cpuChart'), ramChart: $('ramChart'), gpuChart: $('gpuChart')
        };

        const numCores = navigator.hardwareConcurrency || 4;

        const formatNum = n => {
            if (n >= 1e9) return (n/1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n/1e6).toFixed(2) + 'M';
            if (n >= 1e3) return (n/1e3).toFixed(1) + 'K';
            return Math.round(n).toString();
        };

        const formatTime = sec => {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };

        const getTime = () => new Date().toTimeString().split(' ')[0];

        const log = (msg, type = 'info') => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${getTime()}</span><span class="log-type ${type}">[${type.toUpperCase()}]</span><span class="log-msg">${msg}</span>`;
            DOM.logContainer.appendChild(entry);
            DOM.logContainer.scrollTop = DOM.logContainer.scrollHeight;
        };

        const setRing = (ring, percent) => {
            ring.style.strokeDashoffset = CONFIG.RING_CIRCUMFERENCE - (percent / 100) * CONFIG.RING_CIRCUMFERENCE;
        };

        // Score categories 1.5x
        const getRating = score => {
            if (score >= 7500000) return { text: 'üèÜ LEGENDARY', cls: 'legendary' };
            if (score >= 3000000) return { text: 'üî• EXTREME', cls: 'extreme' };
            if (score >= 1500000) return { text: '‚≠ê EXCELLENT', cls: 'excellent' };
            if (score >= 750000) return { text: '‚úì GOOD', cls: 'good' };
            if (score >= 300000) return { text: '‚óÜ AVERAGE', cls: 'average' };
            return { text: '‚óã POOR', cls: 'poor' };
        };

        const getStats = arr => {
            if (!arr.length) return { min: 0, avg: 0, max: 0 };
            return {
                min: Math.min(...arr),
                avg: Math.round(arr.reduce((a,b) => a+b, 0) / arr.length),
                max: Math.max(...arr)
            };
        };

        function setupWorkerIndicators() {
            DOM.coreCount.textContent = numCores;
            DOM.workerGrid.innerHTML = '';
            for (let i = 0; i < numCores; i++) {
                const dot = document.createElement('div');
                dot.className = 'worker-dot';
                dot.id = `worker-${i}`;
                dot.textContent = i + 1;
                DOM.workerGrid.appendChild(dot);
            }
        }

        function resizeCanvas() {
            const c = DOM.gpuCanvas.parentElement;
            DOM.gpuCanvas.width = c.clientWidth;
            DOM.gpuCanvas.height = c.clientHeight;
            if (state.gl) {
                state.gl.viewport(0, 0, DOM.gpuCanvas.width, DOM.gpuCanvas.height);
            }
        }

        function setupCharts() {
            [DOM.cpuChart, DOM.ramChart, DOM.gpuChart].forEach(c => {
                c.width = c.parentElement.clientWidth;
                c.height = c.parentElement.clientHeight;
            });
        }

        document.querySelectorAll('.timer-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (state.running.any) return;
                document.querySelectorAll('.timer-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.timer.duration = parseInt(btn.dataset.time);
                state.timer.remaining = state.timer.duration;
                DOM.countdown.textContent = formatTime(state.timer.remaining);
                DOM.countdownBar.style.width = '100%';
            });
        });

        function initWebGL() {
            const gl = DOM.gpuCanvas.getContext('webgl2') || DOM.gpuCanvas.getContext('webgl');
            if (!gl) {
                log('WebGL not supported!', 'warn');
                return null;
            }
            state.gl = gl;

            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                DOM.glRenderer.textContent = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                DOM.glVendor.textContent = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
            }
            DOM.glMaxTexture.textContent = gl.getParameter(gl.MAX_TEXTURE_SIZE) + 'px';
            DOM.glMaxVertices.textContent = formatNum(gl.getParameter(gl.MAX_ELEMENTS_VERTICES));

            const vsSource = `
                attribute vec2 a_position;
                attribute vec3 a_color;
                attribute float a_size;
                uniform float u_time;
                uniform vec2 u_resolution;
                varying vec3 v_color;
                varying float v_intensity;
                
                void main() {
                    float t = u_time * 0.001;
                    vec2 pos = a_position;
                    
                    float wave1 = sin(pos.x * 10.0 + t * 3.0) * 0.1;
                    float wave2 = cos(pos.y * 8.0 + t * 2.5) * 0.1;
                    float wave3 = sin((pos.x + pos.y) * 6.0 + t * 4.0) * 0.08;
                    float wave4 = cos(length(pos) * 12.0 - t * 5.0) * 0.06;
                    
                    pos.x += wave1 + wave3;
                    pos.y += wave2 + wave4;
                    
                    float angle = t * 0.5 + length(pos) * 2.0;
                    float c = cos(angle * 0.3);
                    float s = sin(angle * 0.3);
                    pos = vec2(pos.x * c - pos.y * s, pos.x * s + pos.y * c) * 0.8;
                    
                    gl_Position = vec4(pos, 0.0, 1.0);
                    gl_PointSize = a_size * (1.0 + sin(t * 5.0 + a_position.x * 20.0) * 0.5);
                    
                    v_color = a_color;
                    v_intensity = 0.5 + 0.5 * sin(t * 3.0 + pos.x * 10.0 + pos.y * 10.0);
                }
            `;

            const fsSource = `
                precision highp float;
                varying vec3 v_color;
                varying float v_intensity;
                uniform float u_time;
                
                void main() {
                    float t = u_time * 0.001;
                    vec2 coord = gl_PointCoord - 0.5;
                    float dist = length(coord);
                    
                    float glow = exp(-dist * 4.0);
                    float pulse = 0.5 + 0.5 * sin(t * 8.0 + dist * 20.0);
                    float ring = smoothstep(0.3, 0.35, dist) * smoothstep(0.45, 0.4, dist);
                    
                    vec3 color = v_color;
                    color += vec3(sin(t * 2.0) * 0.3, cos(t * 2.5) * 0.3, sin(t * 3.0) * 0.3);
                    color = mix(color, vec3(1.0), ring * 0.5);
                    color *= glow * v_intensity * pulse;
                    color *= 1.5;
                    
                    float alpha = glow * (0.6 + pulse * 0.4);
                    if (alpha < 0.01) discard;
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);

            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource);
            gl.compileShader(fs);

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            state.glProgram = program;

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            log(`WebGL initialized - ${DOM.glRenderer.textContent}`, 'gpu');
            return gl;
        }

        let gpuVertexBuffer = null;
        let gpuColorBuffer = null;
        let gpuSizeBuffer = null;

        function createGPUGeometry(triangleCount) {
            const gl = state.gl;
            if (!gl) return;

            const vertexCount = triangleCount * 3;
            const positions = new Float32Array(vertexCount * 2);
            const colors = new Float32Array(vertexCount * 3);
            const sizes = new Float32Array(vertexCount);

            for (let i = 0; i < vertexCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.9;
                positions[i * 2] = Math.cos(angle) * radius;
                positions[i * 2 + 1] = Math.sin(angle) * radius;
                
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
                
                sizes[i] = Math.random() * 8 + 2;
            }

            if (gpuVertexBuffer) gl.deleteBuffer(gpuVertexBuffer);
            gpuVertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
            const posLoc = gl.getAttribLocation(state.glProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            if (gpuColorBuffer) gl.deleteBuffer(gpuColorBuffer);
            gpuColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
            const colorLoc = gl.getAttribLocation(state.glProgram, 'a_color');
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            if (gpuSizeBuffer) gl.deleteBuffer(gpuSizeBuffer);
            gpuSizeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuSizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.DYNAMIC_DRAW);
            const sizeLoc = gl.getAttribLocation(state.glProgram, 'a_size');
            gl.enableVertexAttribArray(sizeLoc);
            gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, 0, 0);

            state.vertexCount = vertexCount;
            state.triangleCount = triangleCount;
        }

        const workerCode = `
            let running = false, ops = 0;
            self.onmessage = e => {
                if (e.data.cmd === 'start') { running = true; stress(); }
                else if (e.data.cmd === 'stop') { running = false; }
            };
            function stress() {
                if (!running) return;
                for (let i = 0; i < 100000; i++) {
                    const n = Math.random() * 999999;
                    Math.sin(n) * Math.cos(n) * Math.tan(n);
                    Math.sqrt(n) * Math.pow(n, 0.5);
                    Math.log(n + 1) * Math.exp(n % 10);
                    let sum = 0;
                    for (let k = 0; k < 10; k++) sum += Math.sin(k * n);
                    ops += 20;
                }
                self.postMessage({ ops });
                setTimeout(stress, 0);
            }
        `;

        function createWorkers() {
            terminateWorkers();
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            for (let i = 0; i < numCores; i++) {
                const w = new Worker(url);
                w.onmessage = e => state.workerStats[i] = e.data.ops;
                state.workers.push(w);
                state.workerStats.push(0);
            }
            URL.revokeObjectURL(url);
        }

        function startWorkers() {
            state.workers.forEach((w, i) => {
                w.postMessage({ cmd: 'start' });
                const dot = document.getElementById(`worker-${i}`);
                if (dot) dot.classList.add('active');
            });
        }

        function stopWorkers() {
            state.workers.forEach((w, i) => {
                w.postMessage({ cmd: 'stop' });
                const dot = document.getElementById(`worker-${i}`);
                if (dot) dot.classList.remove('active');
            });
        }

        function terminateWorkers() {
            state.workers.forEach(w => w.terminate());
            state.workers = [];
            state.workerStats = [];
        }

        let cpuStartTime = 0, mainOps = 0;

        function cpuStress() {
            if (!state.running.cpu) return;
            for (let i = 0; i < 50000; i++) {
                const n = Math.random() * 999999;
                Math.sin(n) * Math.cos(n) * Math.tan(n);
                mainOps += 4;
            }
            const totalOps = state.workerStats.reduce((a,b) => a+b, 0) + mainOps;
            const elapsed = Math.max((performance.now() - cpuStartTime) / 1000, 0.1);
            const opsPerSec = totalOps / elapsed;

            // Capped at 85%
            state.usage.cpu = Math.min(CONFIG.MAX_USAGE_PERCENT, state.usage.cpu + 1.5);
            state.scores.cpu = Math.round((opsPerSec / 25) * CONFIG.SCORE_MULTIPLIER);
            state.scoreHistory.cpu.push(state.scores.cpu);

            DOM.cpuPercent.textContent = Math.round(state.usage.cpu) + '%';
            DOM.cpuRingValue.textContent = Math.round(state.usage.cpu);
            setRing(DOM.cpuRing, state.usage.cpu);
            DOM.cpuOps.textContent = formatNum(totalOps);
            DOM.cpuOpsPerSec.textContent = formatNum(opsPerSec);
            DOM.cpuThreads.textContent = numCores + 1;
            DOM.cpuScore.textContent = formatNum(state.scores.cpu);
            DOM.cpuUsageSmall.textContent = Math.round(state.usage.cpu) + '%';
            DOM.activeWorkers.textContent = numCores;

            state.charts.cpu.push(state.usage.cpu);
            if (state.charts.cpu.length > CONFIG.CHART_SIZE) state.charts.cpu.shift();

            setTimeout(cpuStress, 0);
        }

        function startCPU() {
            if (state.running.cpu) return;
            state.running.cpu = true;
            cpuStartTime = performance.now();
            mainOps = 0;
            state.workerStats = state.workerStats.map(() => 0);
            createWorkers();
            startWorkers();
            DOM.cpuCard.classList.add('stress');
            DOM.cpuStatus.textContent = 'üî¥ RUNNING';
            log(`CPU stress started - ${numCores + 1} threads`, 'cpu');
            cpuStress();
        }

        function stopCPU() {
            state.running.cpu = false;
            stopWorkers();
            DOM.cpuCard.classList.remove('stress');
            DOM.cpuStatus.textContent = 'Stopped';
        }

        let ramStartTime = 0, totalRamAlloc = 0;

        function ramStress() {
            if (!state.running.ram) return;
            try {
                const chunkSize = CONFIG.RAM_CHUNK_MB * 1024 * 1024;
                const writeStart = performance.now();
                const buffer = new ArrayBuffer(chunkSize);
                const view = new Float64Array(buffer);
                for (let i = 0; i < view.length; i++) view[i] = Math.random() * i;
                const writeTime = Math.max((performance.now() - writeStart) / 1000, 0.001);
                const writeSpeed = (chunkSize / (1024 * 1024)) / writeTime;

                state.ramBuffers.push(buffer);
                totalRamAlloc += chunkSize;

                const maxAlloc = CONFIG.MAX_RAM_MB * 1024 * 1024;
                while (totalRamAlloc > maxAlloc && state.ramBuffers.length > 1) {
                    totalRamAlloc -= state.ramBuffers.shift().byteLength;
                }

                const allocMB = totalRamAlloc / (1024 * 1024);
                // Capped at 85%
                state.usage.ram = Math.min(CONFIG.MAX_USAGE_PERCENT, (totalRamAlloc / maxAlloc) * 100);
                state.scores.ram = Math.round((writeSpeed * 100 + allocMB * 8) * CONFIG.SCORE_MULTIPLIER);
                state.scoreHistory.ram.push(state.scores.ram);

                DOM.ramPercent.textContent = Math.round(state.usage.ram) + '%';
                DOM.ramRingValue.textContent = Math.round(state.usage.ram);
                setRing(DOM.ramRing, state.usage.ram);
                DOM.ramAllocated.textContent = allocMB.toFixed(0) + ' MB';
                DOM.ramBuffers.textContent = state.ramBuffers.length;
                DOM.ramWrite.textContent = writeSpeed.toFixed(0);
                DOM.ramScore.textContent = formatNum(state.scores.ram);
                DOM.ramUsageSmall.textContent = allocMB.toFixed(0) + ' MB';
                DOM.bufferCount.textContent = state.ramBuffers.length;

                state.charts.ram.push(state.usage.ram);
                if (state.charts.ram.length > CONFIG.CHART_SIZE) state.charts.ram.shift();
            } catch (e) {
                log('RAM limit reached!', 'warn');
            }
            setTimeout(ramStress, 40);
        }

        function startRAM() {
            if (state.running.ram) return;
            state.running.ram = true;
            ramStartTime = performance.now();
            totalRamAlloc = 0;
            state.ramBuffers = [];
            DOM.ramCard.classList.add('stress');
            DOM.ramStatus.textContent = 'üü¢ ALLOCATING';
            log(`RAM stress started - Target: ${CONFIG.MAX_RAM_MB} MB`, 'ram');
            ramStress();
        }

        function stopRAM() {
            state.running.ram = false;
            state.ramBuffers = [];
            totalRamAlloc = 0;
            DOM.ramCard.classList.remove('stress');
            DOM.ramStatus.textContent = 'Stopped';
        }

        let gpuStartTime = 0;

        function gpuRender(time) {
            if (!state.running.gpu) {
                const gl = state.gl;
                if (gl) {
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
                return;
            }

            const gl = state.gl;
            if (!gl) return;

            // Max triangles for 85% load
            const targetTriangles = Math.floor(CONFIG.MAX_TRIANGLES * (CONFIG.MAX_USAGE_PERCENT / 100));
            if (state.triangleCount < targetTriangles) {
                const newCount = Math.min(state.triangleCount + CONFIG.TRIANGLE_BATCH, targetTriangles);
                createGPUGeometry(newCount);
            }

            gl.clearColor(0.01, 0.01, 0.02, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const timeLoc = gl.getUniformLocation(state.glProgram, 'u_time');
            const resLoc = gl.getUniformLocation(state.glProgram, 'u_resolution');
            gl.uniform1f(timeLoc, time);
            gl.uniform2f(resLoc, DOM.gpuCanvas.width, DOM.gpuCanvas.height);

            state.drawCalls = 0;
            for (let pass = 0; pass < 5; pass++) {
                gl.drawArrays(gl.POINTS, 0, state.vertexCount);
                state.drawCalls++;
            }

            // Capped at 85%
            state.usage.gpu = Math.min(CONFIG.MAX_USAGE_PERCENT, (state.triangleCount / CONFIG.MAX_TRIANGLES) * 100);
            state.scores.gpu = Math.round(((state.triangleCount * state.fps.current * state.drawCalls) / 50) * CONFIG.SCORE_MULTIPLIER);
            state.scoreHistory.gpu.push(state.scores.gpu);

            DOM.gpuPercent.textContent = Math.round(state.usage.gpu) + '%';
            DOM.gpuRingValue.textContent = Math.round(state.usage.gpu);
            setRing(DOM.gpuRing, state.usage.gpu);
            DOM.gpuVertices.textContent = formatNum(state.vertexCount);
            DOM.gpuDrawCalls.textContent = state.drawCalls;
            DOM.gpuTriangles.textContent = formatNum(state.triangleCount);
            DOM.gpuScore.textContent = formatNum(state.scores.gpu);
            DOM.gpuUsageSmall.textContent = Math.round(state.usage.gpu) + '%';
            DOM.objectCount.textContent = formatNum(state.triangleCount);
            DOM.canvasTriangles.textContent = formatNum(state.triangleCount);
            DOM.canvasVertices.textContent = formatNum(state.vertexCount);

            state.charts.gpu.push(state.usage.gpu);
            if (state.charts.gpu.length > CONFIG.CHART_SIZE) state.charts.gpu.shift();

            setTimeout(() => gpuRender(performance.now()), 0);
        }

        function startGPU() {
            if (state.running.gpu) return;
            state.running.gpu = true;
            gpuStartTime = performance.now();
            state.triangleCount = 0;
            state.vertexCount = 0;
            
            if (!state.gl) {
                initWebGL();
            }
            
            createGPUGeometry(CONFIG.TRIANGLE_BATCH);
            
            DOM.gpuCard.classList.add('stress');
            DOM.gpuStatus.textContent = 'üü£ RENDERING';
            log(`GPU stress started - Target: ${formatNum(CONFIG.MAX_TRIANGLES)} triangles (WebGL)`, 'gpu');
            gpuRender(performance.now());
        }

        function stopGPU() {
            state.running.gpu = false;
            state.triangleCount = 0;
            state.vertexCount = 0;
            DOM.gpuCard.classList.remove('stress');
            DOM.gpuStatus.textContent = 'Stopped';
        }

        let fpsFrames = 0, lastFpsUpdate = performance.now();

        function fpsLoop() {
            fpsFrames++;
            const now = performance.now();
            if (now - lastFpsUpdate >= 100) {
                state.fps.current = Math.round((fpsFrames / (now - lastFpsUpdate)) * 1000);
                if (state.fps.current > state.fps.max) state.fps.max = state.fps.current;
                DOM.fpsDisplay.textContent = state.fps.current;
                DOM.fpsMax.textContent = state.fps.max;
                DOM.canvasFps.textContent = state.fps.current;
                fpsFrames = 0;
                lastFpsUpdate = now;
            }
            setTimeout(fpsLoop, 0);
        }

        function startTimer() {
            state.timer.remaining = state.timer.duration;
            state.timer.startTime = Date.now();
            state.timer.interval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - state.timer.startTime) / 1000);
                state.timer.remaining = Math.max(0, state.timer.duration - elapsed);
                DOM.countdown.textContent = formatTime(state.timer.remaining);
                DOM.countdownBar.style.width = ((state.timer.remaining / state.timer.duration) * 100) + '%';

                if (state.timer.remaining <= 0) {
                    finishBenchmark();
                }
            }, 100);
        }

        function stopTimer() {
            if (state.timer.interval) {
                clearInterval(state.timer.interval);
                state.timer.interval = null;
            }
        }

        function startBenchmark() {
            state.running.any = true;
            state.scoreHistory = { cpu: [], ram: [], gpu: [] };
            state.usage = { cpu: 0, ram: 0, gpu: 0 };
            state.scores = { cpu: 0, ram: 0, gpu: 0 };
            state.charts = { cpu: [], ram: [], gpu: [] };
            state.fps.max = 0;

            DOM.resultsSection.classList.remove('show');
            DOM.btnStart.disabled = true;
            DOM.btnStop.disabled = false;
            document.querySelectorAll('.timer-btn').forEach(b => b.disabled = true);

            startTimer();
            startCPU();
            startRAM();
            startGPU();

            log(`Benchmark started - Duration: ${formatTime(state.timer.duration)} | Max Load: ${CONFIG.MAX_USAGE_PERCENT}%`, 'info');
        }

        function stopBenchmark() {
            state.running.any = false;
            stopTimer();
            stopCPU();
            stopRAM();
            stopGPU();

            DOM.btnStart.disabled = false;
            DOM.btnStop.disabled = true;
            document.querySelectorAll('.timer-btn').forEach(b => b.disabled = false);

            log('Benchmark stopped by user', 'warn');
        }

        function finishBenchmark() {
            state.running.any = false;
            stopTimer();
            stopCPU();
            stopRAM();
            stopGPU();

            DOM.btnStart.disabled = false;
            DOM.btnStop.disabled = true;
            document.querySelectorAll('.timer-btn').forEach(b => b.disabled = false);

            const cpuStats = getStats(state.scoreHistory.cpu);
            const ramStats = getStats(state.scoreHistory.ram);
            const gpuStats = getStats(state.scoreHistory.gpu);
            const finalTotal = cpuStats.avg + ramStats.avg + gpuStats.avg;
            const rating = getRating(finalTotal);

            DOM.finalScore.textContent = formatNum(finalTotal);
            DOM.finalRating.innerHTML = `<span class="category-badge ${rating.cls}" style="margin-top:15px;display:inline-block;padding:10px 30px;font-size:1rem;">${rating.text}</span>`;

            DOM.cpuMin.textContent = formatNum(cpuStats.min);
            DOM.cpuAvg.textContent = formatNum(cpuStats.avg);
            DOM.cpuMax.textContent = formatNum(cpuStats.max);

            DOM.ramMin.textContent = formatNum(ramStats.min);
            DOM.ramAvg.textContent = formatNum(ramStats.avg);
            DOM.ramMax.textContent = formatNum(ramStats.max);

            DOM.gpuMin.textContent = formatNum(gpuStats.min);
            DOM.gpuAvg.textContent = formatNum(gpuStats.avg);
            DOM.gpuMax.textContent = formatNum(gpuStats.max);

            DOM.resultsSection.classList.add('show');
            DOM.resultsSection.scrollIntoView({ behavior: 'smooth' });

            log(`üèÅ Benchmark complete! Final Score: ${formatNum(finalTotal)} - ${rating.text}`, 'done');
        }

        function drawChart(cvs, data, color) {
            const c = cvs.getContext('2d');
            const w = cvs.width, h = cvs.height;
            c.clearRect(0, 0, w, h);
            if (data.length < 2) return;

            c.strokeStyle = 'rgba(255,255,255,0.03)';
            c.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                c.beginPath();
                c.moveTo(0, (h/4)*i);
                c.lineTo(w, (h/4)*i);
                c.stroke();
            }

            const step = w / (CONFIG.CHART_SIZE - 1);
            c.beginPath();
            c.strokeStyle = color;
            c.lineWidth = 2;
            for (let i = 0; i < data.length; i++) {
                const x = i * step;
                const y = h - (data[i] / 100) * h;
                i === 0 ? c.moveTo(x, y) : c.lineTo(x, y);
            }
            c.stroke();

            c.lineTo((data.length - 1) * step, h);
            c.lineTo(0, h);
            c.closePath();
            c.fillStyle = color.replace('rgb', 'rgba').replace(')', ', 0.15)');
            c.fill();
        }

        function updateScore() {
            const total = state.scores.cpu + state.scores.ram + state.scores.gpu;
            const rating = getRating(total);
            DOM.totalScore.textContent = formatNum(total);
            DOM.breakdownCpu.textContent = formatNum(state.scores.cpu);
            DOM.breakdownRam.textContent = formatNum(state.scores.ram);
            DOM.breakdownGpu.textContent = formatNum(state.scores.gpu);
            DOM.scoreRating.innerHTML = `<span class="category-badge ${rating.cls}" style="margin-top:10px;display:inline-block;">${rating.text}</span>`;
        }

        function mainLoop() {
            drawChart(DOM.cpuChart, state.charts.cpu, 'rgb(255, 45, 85)');
            drawChart(DOM.ramChart, state.charts.ram, 'rgb(48, 209, 88)');
            drawChart(DOM.gpuChart, state.charts.gpu, 'rgb(191, 90, 242)');
            updateScore();
            requestAnimationFrame(mainLoop);
        }

        DOM.btnStart.addEventListener('click', startBenchmark);
        DOM.btnStop.addEventListener('click', stopBenchmark);

        DOM.btnCpu.addEventListener('click', () => {
            if (!state.running.any) {
                state.running.any = true;
                state.scoreHistory.cpu = [];
                DOM.btnStart.disabled = true;
                DOM.btnStop.disabled = false;
                document.querySelectorAll('.timer-btn').forEach(b => b.disabled = true);
                startTimer();
                startCPU();
            }
        });

        DOM.btnRam.addEventListener('click', () => {
            if (!state.running.any) {
                state.running.any = true;
                state.scoreHistory.ram = [];
                DOM.btnStart.disabled = true;
                DOM.btnStop.disabled = false;
                document.querySelectorAll('.timer-btn').forEach(b => b.disabled = true);
                startTimer();
                startRAM();
            }
        });

        DOM.btnGpu.addEventListener('click', () => {
            if (!state.running.any) {
                state.running.any = true;
                state.scoreHistory.gpu = [];
                DOM.btnStart.disabled = true;
                DOM.btnStop.disabled = false;
                document.querySelectorAll('.timer-btn').forEach(b => b.disabled = true);
                startTimer();
                startGPU();
            }
        });

        DOM.btnClearLog.addEventListener('click', () => {
            DOM.logContainer.innerHTML = '';
            log('Log cleared', 'info');
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            setupCharts();
        });

        function init() {
            setupWorkerIndicators();
            resizeCanvas();
            setupCharts();
            initWebGL();
            state.timer.remaining = state.timer.duration;
            DOM.countdown.textContent = formatTime(state.timer.remaining);
            log('‚ö° Ultra Benchmark Pro v2 - Jovian.my.id', 'info');
            log(`Max Usage: ${CONFIG.MAX_USAGE_PERCENT}% | Score Multiplier: ${CONFIG.SCORE_MULTIPLIER}x`, 'info');
            log(`Detected ${numCores} CPU cores`, 'cpu');
            log(`RAM target: ${CONFIG.MAX_RAM_MB} MB`, 'ram');
            log(`GPU triangles: ${formatNum(CONFIG.MAX_TRIANGLES)} (WebGL)`, 'gpu');
            fpsLoop();
            mainLoop();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
